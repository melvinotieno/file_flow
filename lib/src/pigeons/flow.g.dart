// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse({Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

/// Represents the base storage directory for task files.
///
/// The temporary path and paths prefixed with `application` correspond to
/// those provided by the `path_provider` package. For more details, see:
/// https://pub.dev/packages/path_provider
///
/// The remaining directories are visible to the user i.e. they can easily
/// access the files stored in these directories from the file manager.
enum StorageDirectory {
  /// Path to a directory where the application may place application-specific
  /// cache files.
  ///
  /// If this directory does not exist, it is created automatically.
  applicationCache,
  /// Path to a directory where the application may place data that is
  /// user-generated, or that cannot otherwise be recreated by your application.
  ///
  /// Consider using another path, such as [applicationSupport], or
  /// [applicationCache], if the data is not user-generated.
  applicationDocuments,
  /// Path to the directory where application can store files that are
  /// persistent, backed up, and not visible to the user, such as sqlite.db.
  ///
  /// This directory is only supported on iOS and macOS.
  applicationLibrary,
  /// Path to a directory where the application may place application support
  /// files.
  ///
  /// If this directory does not exist, it is created automatically.
  ///
  /// Use this for files you don't want exposed to the user. Your app should not
  /// use this directory for user data files.
  applicationSupport,
  /// Path to the temporary directory on the device that is not backed up and is
  /// suitable for storing caches of downloaded files.
  ///
  /// Files in this directory may be cleared at any time. This does *not* return
  /// a new temporary directory. Instead, the caller is responsible for creating
  /// (and cleaning up) files or directories within this directory. This
  /// directory is scoped to the calling application.
  temporary,
  /// Path to downloaded files.
  downloads,
  /// Path to image files.
  images,
  /// Path to video files.
  video,
  /// Path to audio files.
  audio,
  /// Path to general files that do not fit the other categories. This is only
  /// available on Android.
  files,
}

/// Defines what type a task is.
enum TaskType {
  /// A task that downloads a file from a specified URL.
  download,
  /// A task that uploads a file to a specified URL.
  upload,
  /// A task that uploads multiple files to a specified URL.
  multiUpload,
  /// A task that downloads a file in chunks from one or more URLs.
  parallelDownload,
}

/// The state of a task.
enum TaskState {
  /// The task has been enqueued waiting to be executed.
  ///
  /// A task can remain in this state until certain constraints, if any, are
  /// met. For example, a task may be waiting for a network connection to be
  /// established before it can be executed.
  pending,
  /// The task is being executed. For example, if the task is a `DownloadTask`,
  /// this state indicates that the task is currently downloading the file.
  running,
  /// The task has been paused and may be resumed.
  paused,
  /// The task has been canceled. This can either be intentionally by the user
  /// or by the system.
  canceled,
  /// The task has been completed successfully.
  completed,
  /// The task has failed due to an error it encountered during its execution.
  failed,
}

/// The error code of a task exception.
enum TaskErrorCode {
  /// The error resulted from the url(s) being invalid.
  url,
  /// A network connection error resulted in the task failing.
  connection,
  /// An error was found in the response from the server.
  http,
  /// The error resulted during the file transfer process.
  transfer,
  /// An error occurred while writing to the filesystem.
  filesystem,
  /// The error was caused by an unknown reason.
  unknown,
}

/// Represents an exception that occurred during a task execution.
class TaskException {
  TaskException({
    required this.code,
    required this.message,
    this.rawResponse,
  });

  /// The error code of the exception.
  TaskErrorCode code;

  /// The error message of the exception.
  String message;

  /// The response from the server that caused the exception. If provided, the
  /// exception is considered to be as a result of a failed HTTP request.
  String? rawResponse;

  Object encode() {
    return <Object?>[
      code,
      message,
      rawResponse,
    ];
  }

  static TaskException decode(Object result) {
    result as List<Object?>;
    return TaskException(
      code: result[0]! as TaskErrorCode,
      message: result[1]! as String,
      rawResponse: result[2] as String?,
    );
  }
}

/// The progress data of a task.
class TaskProgressData {
  TaskProgressData({
    required this.expectedBytes,
    required this.transferredBytes,
    required this.networkSpeed,
  });

  /// The total number of bytes that are expected to be transferred.
  int expectedBytes;

  /// The number of bytes that have been transferred.
  int transferredBytes;

  /// The network speed in bytes per second.
  int networkSpeed;

  Object encode() {
    return <Object?>[
      expectedBytes,
      transferredBytes,
      networkSpeed,
    ];
  }

  static TaskProgressData decode(Object result) {
    result as List<Object?>;
    return TaskProgressData(
      expectedBytes: result[0]! as int,
      transferredBytes: result[1]! as int,
      networkSpeed: result[2]! as int,
    );
  }
}

/// The data of a task that has been paused.
class TaskResumeData {
  TaskResumeData({
    required this.taskString,
    required this.tempPath,
    required this.transferredBytes,
  });

  /// The string representation of the task.
  String taskString;

  /// The temporary path of the task file.
  String tempPath;

  /// The number of bytes that have been transferred.
  int transferredBytes;

  Object encode() {
    return <Object?>[
      taskString,
      tempPath,
      transferredBytes,
    ];
  }

  static TaskResumeData decode(Object result) {
    result as List<Object?>;
    return TaskResumeData(
      taskString: result[0]! as String,
      tempPath: result[1]! as String,
      transferredBytes: result[2]! as int,
    );
  }
}

/// The data of a task that has been completed.
class TaskCompleteData {
  TaskCompleteData({
    required this.path,
    required this.mimeType,
    required this.rawResponse,
  });

  /// The path of the task file.
  ///
  /// This is the path to the file that was downloaded or uploaded.
  String path;

  /// The MIME type of the task file.
  String mimeType;

  /// The server response of the url request.
  String rawResponse;

  Object encode() {
    return <Object?>[
      path,
      mimeType,
      rawResponse,
    ];
  }

  static TaskCompleteData decode(Object result) {
    result as List<Object?>;
    return TaskCompleteData(
      path: result[0]! as String,
      mimeType: result[1]! as String,
      rawResponse: result[2]! as String,
    );
  }
}

/// The task used by native code for execution.
class Task {
  Task({
    required this.type,
    required this.id,
    required this.group,
    required this.method,
    required this.headers,
    required this.timeout,
    required this.retries,
    this.proxyAddress,
    this.proxyPort,
    this.url,
    this.urls,
    this.chunks,
    this.directoryUri,
    required this.baseDirectory,
    this.directory,
    this.filename,
  });

  /// The type of task to execute.
  TaskType type;

  /// The unique identifier of the task.
  String id;

  /// The group identifier of the task.
  String group;

  /// The HTTP method to use for the request.
  String method;

  /// The headers to send with the request.
  Map<String, String> headers;

  /// The timeout for the task in milliseconds.
  int timeout;

  /// The number of times to retry the task request if it fails.
  int retries;

  /// The proxy address to use for the task request.
  String? proxyAddress;

  /// The proxy port to use with the proxy address.
  int? proxyPort;

  /// The url to use for the task request. This is required for all the tasks
  /// that are not of type [TaskType.parallelDownload].
  String? url;

  /// A list of urls to use for the task request. This is required for tasks of
  /// type [TaskType.parallelDownload].
  List<String>? urls;

  /// The number of chunks to download per URL for [TaskType.parallelDownload].
  int? chunks;

  /// The directory URI for download tasks.
  ///
  /// Used in place of [baseDirectory]/[directory].
  String? directoryUri;

  /// The base directory for the task files.
  StorageDirectory baseDirectory;

  /// The child directory within the base directory for the task files.
  String? directory;

  /// The filename of the task file.
  String? filename;

  Object encode() {
    return <Object?>[
      type,
      id,
      group,
      method,
      headers,
      timeout,
      retries,
      proxyAddress,
      proxyPort,
      url,
      urls,
      chunks,
      directoryUri,
      baseDirectory,
      directory,
      filename,
    ];
  }

  static Task decode(Object result) {
    result as List<Object?>;
    return Task(
      type: result[0]! as TaskType,
      id: result[1]! as String,
      group: result[2]! as String,
      method: result[3]! as String,
      headers: (result[4] as Map<Object?, Object?>?)!.cast<String, String>(),
      timeout: result[5]! as int,
      retries: result[6]! as int,
      proxyAddress: result[7] as String?,
      proxyPort: result[8] as int?,
      url: result[9] as String?,
      urls: (result[10] as List<Object?>?)?.cast<String>(),
      chunks: result[11] as int?,
      directoryUri: result[12] as String?,
      baseDirectory: result[13]! as StorageDirectory,
      directory: result[14] as String?,
      filename: result[15] as String?,
    );
  }
}

/// Represents a task event.
sealed class TaskEvent {
}

/// The status event of a task execution.
class TaskStatus extends TaskEvent {
  TaskStatus({
    required this.taskId,
    required this.taskGroup,
    required this.state,
    this.completeData,
    this.resumeData,
    this.exception,
  });

  /// The task id.
  String taskId;

  /// The task group.
  String taskGroup;

  /// The current state of the task.
  TaskState state;

  /// The data associated with a [TaskState.completed] state.
  TaskCompleteData? completeData;

  /// The data associated with a [TaskState.paused] state.
  TaskResumeData? resumeData;

  /// The exception that occurred during the task execution. This is only
  /// provided if the task state is [TaskState.failed].
  TaskException? exception;

  Object encode() {
    return <Object?>[
      taskId,
      taskGroup,
      state,
      completeData,
      resumeData,
      exception,
    ];
  }

  static TaskStatus decode(Object result) {
    result as List<Object?>;
    return TaskStatus(
      taskId: result[0]! as String,
      taskGroup: result[1]! as String,
      state: result[2]! as TaskState,
      completeData: result[3] as TaskCompleteData?,
      resumeData: result[4] as TaskResumeData?,
      exception: result[5] as TaskException?,
    );
  }
}

/// The progress event of a task execution.
class TaskProgress extends TaskEvent {
  TaskProgress({
    required this.taskId,
    required this.taskGroup,
    required this.progress,
    required this.data,
  });

  /// The task id.
  String taskId;

  /// The task group.
  String taskGroup;

  /// The progress of the task.
  int progress;

  /// The progress data of the task.
  TaskProgressData data;

  Object encode() {
    return <Object?>[
      taskId,
      taskGroup,
      progress,
      data,
    ];
  }

  static TaskProgress decode(Object result) {
    result as List<Object?>;
    return TaskProgress(
      taskId: result[0]! as String,
      taskGroup: result[1]! as String,
      progress: result[2]! as int,
      data: result[3]! as TaskProgressData,
    );
  }
}


class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    }    else if (value is StorageDirectory) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    }    else if (value is TaskType) {
      buffer.putUint8(130);
      writeValue(buffer, value.index);
    }    else if (value is TaskState) {
      buffer.putUint8(131);
      writeValue(buffer, value.index);
    }    else if (value is TaskErrorCode) {
      buffer.putUint8(132);
      writeValue(buffer, value.index);
    }    else if (value is TaskException) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    }    else if (value is TaskProgressData) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    }    else if (value is TaskResumeData) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    }    else if (value is TaskCompleteData) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    }    else if (value is Task) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    }    else if (value is TaskStatus) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    }    else if (value is TaskProgress) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : StorageDirectory.values[value];
      case 130: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : TaskType.values[value];
      case 131: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : TaskState.values[value];
      case 132: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : TaskErrorCode.values[value];
      case 133: 
        return TaskException.decode(readValue(buffer)!);
      case 134: 
        return TaskProgressData.decode(readValue(buffer)!);
      case 135: 
        return TaskResumeData.decode(readValue(buffer)!);
      case 136: 
        return TaskCompleteData.decode(readValue(buffer)!);
      case 137: 
        return Task.decode(readValue(buffer)!);
      case 138: 
        return TaskStatus.decode(readValue(buffer)!);
      case 139: 
        return TaskProgress.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class FileFlowHostApi {
  /// Constructor for [FileFlowHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  FileFlowHostApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Enqueues a task for execution.
  ///
  /// Returns `true` if the task was successfully enqueued; otherwise, `false`.
  Future<bool> enqueue(Task task) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.file_flow.FileFlowHostApi.enqueue$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[task]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Pauses a task with the specified id.
  ///
  /// Returns `true` if the task was successfully paused; otherwise, `false`.
  Future<bool> pauseWithId(String taskId) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.file_flow.FileFlowHostApi.pauseWithId$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[taskId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Resumes a task with the specified resume data.
  ///
  /// Returns `true` if the task was successfully resumed; otherwise, `false`.
  Future<bool> resume(TaskResumeData resumeData) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.file_flow.FileFlowHostApi.resume$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[resumeData]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Cancels a task with the specified id.
  ///
  /// Returns `true` if the task was successfully canceled; otherwise, `false`.
  Future<bool> cancelWithId(String taskId) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.file_flow.FileFlowHostApi.cancelWithId$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[taskId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }
}

abstract class FileFlowFlutterApi {
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  /// Handles the status update of a task.
  void onStatusUpdate(TaskStatus taskStatus);

  /// Handles the progress update of a task.
  void onProgressUpdate(TaskProgress taskProgress);

  static void setUp(FileFlowFlutterApi? api, {BinaryMessenger? binaryMessenger, String messageChannelSuffix = '',}) {
    messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.file_flow.FileFlowFlutterApi.onStatusUpdate$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.file_flow.FileFlowFlutterApi.onStatusUpdate was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final TaskStatus? arg_taskStatus = (args[0] as TaskStatus?);
          assert(arg_taskStatus != null,
              'Argument for dev.flutter.pigeon.file_flow.FileFlowFlutterApi.onStatusUpdate was null, expected non-null TaskStatus.');
          try {
            api.onStatusUpdate(arg_taskStatus!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.file_flow.FileFlowFlutterApi.onProgressUpdate$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.file_flow.FileFlowFlutterApi.onProgressUpdate was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final TaskProgress? arg_taskProgress = (args[0] as TaskProgress?);
          assert(arg_taskProgress != null,
              'Argument for dev.flutter.pigeon.file_flow.FileFlowFlutterApi.onProgressUpdate was null, expected non-null TaskProgress.');
          try {
            api.onProgressUpdate(arg_taskProgress!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}
