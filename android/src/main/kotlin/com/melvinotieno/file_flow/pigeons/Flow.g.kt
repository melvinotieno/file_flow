// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.melvinotieno.file_flow.pigeons

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlowFlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlowFlutterError {
  return FlowFlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlowFlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/**
 * Represents the base storage directory for task files.
 *
 * The temporary path and paths prefixed with `application` correspond to
 * those provided by the `path_provider` package. For more details, see:
 * https://pub.dev/packages/path_provider
 *
 * The remaining directories are visible to the user i.e. they can easily
 * access the files stored in these directories from the file manager.
 */
enum class StorageDirectory(val raw: Int) {
  /**
   * Path to a directory where the application may place application-specific
   * cache files.
   *
   * If this directory does not exist, it is created automatically.
   */
  APPLICATION_CACHE(0),
  /**
   * Path to a directory where the application may place data that is
   * user-generated, or that cannot otherwise be recreated by your application.
   *
   * Consider using another path, such as [applicationSupport], or
   * [applicationCache], if the data is not user-generated.
   */
  APPLICATION_DOCUMENTS(1),
  /**
   * Path to the directory where application can store files that are
   * persistent, backed up, and not visible to the user, such as sqlite.db.
   *
   * This directory is only supported on iOS and macOS.
   */
  APPLICATION_LIBRARY(2),
  /**
   * Path to a directory where the application may place application support
   * files.
   *
   * If this directory does not exist, it is created automatically.
   *
   * Use this for files you don't want exposed to the user. Your app should not
   * use this directory for user data files.
   */
  APPLICATION_SUPPORT(3),
  /**
   * Path to the temporary directory on the device that is not backed up and is
   * suitable for storing caches of downloaded files.
   *
   * Files in this directory may be cleared at any time. This does *not* return
   * a new temporary directory. Instead, the caller is responsible for creating
   * (and cleaning up) files or directories within this directory. This
   * directory is scoped to the calling application.
   */
  TEMPORARY(4),
  /** Path to downloaded files. */
  DOWNLOADS(5),
  /** Path to image files. */
  IMAGES(6),
  /** Path to video files. */
  VIDEO(7),
  /** Path to audio files. */
  AUDIO(8),
  /**
   * Path to general files that do not fit the other categories. This is only
   * available on Android.
   */
  FILES(9);

  companion object {
    fun ofRaw(raw: Int): StorageDirectory? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Defines what type a task is. */
enum class TaskType(val raw: Int) {
  /** A task that downloads a file from a specified URL. */
  DOWNLOAD(0),
  /** A task that uploads a file to a specified URL. */
  UPLOAD(1),
  /** A task that uploads multiple files to a specified URL. */
  MULTI_UPLOAD(2),
  /** A task that downloads a file in chunks from one or more URLs. */
  PARALLEL_DOWNLOAD(3);

  companion object {
    fun ofRaw(raw: Int): TaskType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The state of a task. */
enum class TaskState(val raw: Int) {
  /**
   * The task has been enqueued waiting to be executed.
   *
   * A task can remain in this state until certain constraints, if any, are
   * met. For example, a task may be waiting for a network connection to be
   * established before it can be executed.
   */
  PENDING(0),
  /**
   * The task is being executed. For example, if the task is a `DownloadTask`,
   * this state indicates that the task is currently downloading the file.
   */
  RUNNING(1),
  /** The task has been paused and may be resumed. */
  PAUSED(2),
  /**
   * The task has been canceled. This can either be intentionally by the user
   * or by the system.
   */
  CANCELED(3),
  /** The task has been completed successfully. */
  COMPLETED(4),
  /** The task has failed due to an error it encountered during its execution. */
  FAILED(5);

  companion object {
    fun ofRaw(raw: Int): TaskState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The error code of a task exception. */
enum class TaskErrorCode(val raw: Int) {
  /** The error resulted from the url(s) being invalid. */
  URL(0),
  /** A network connection error resulted in the task failing. */
  CONNECTION(1),
  /** An error was found in the response from the server. */
  HTTP(2),
  /** The error resulted during the file transfer process. */
  TRANSFER(3),
  /** An error occurred while writing to the filesystem. */
  FILESYSTEM(4),
  /** The error was caused by an unknown reason. */
  UNKNOWN(5);

  companion object {
    fun ofRaw(raw: Int): TaskErrorCode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Represents an exception that occurred during a task execution.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TaskException (
  /** The error code of the exception. */
  val code: TaskErrorCode,
  /** The error message of the exception. */
  val message: String,
  /**
   * The response from the server that caused the exception. If provided, the
   * exception is considered to be as a result of a failed HTTP request.
   */
  val rawResponse: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TaskException {
      val code = pigeonVar_list[0] as TaskErrorCode
      val message = pigeonVar_list[1] as String
      val rawResponse = pigeonVar_list[2] as String?
      return TaskException(code, message, rawResponse)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      code,
      message,
      rawResponse,
    )
  }
}

/**
 * The progress data of a task.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TaskProgressData (
  /** The total number of bytes that are expected to be transferred. */
  val expectedBytes: Long,
  /** The number of bytes that have been transferred. */
  val transferredBytes: Long,
  /** The network speed in bytes per second. */
  val networkSpeed: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TaskProgressData {
      val expectedBytes = pigeonVar_list[0] as Long
      val transferredBytes = pigeonVar_list[1] as Long
      val networkSpeed = pigeonVar_list[2] as Long
      return TaskProgressData(expectedBytes, transferredBytes, networkSpeed)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      expectedBytes,
      transferredBytes,
      networkSpeed,
    )
  }
}

/**
 * The data of a task that has been paused.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TaskResumeData (
  /** The string representation of the task. */
  val taskString: String,
  /** The temporary path of the task file. */
  val tempPath: String,
  /** The number of bytes that have been transferred. */
  val transferredBytes: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TaskResumeData {
      val taskString = pigeonVar_list[0] as String
      val tempPath = pigeonVar_list[1] as String
      val transferredBytes = pigeonVar_list[2] as Long
      return TaskResumeData(taskString, tempPath, transferredBytes)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      taskString,
      tempPath,
      transferredBytes,
    )
  }
}

/**
 * The data of a task that has been completed.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TaskCompleteData (
  /**
   * The path of the task file.
   *
   * This is the path to the file that was downloaded or uploaded.
   */
  val path: String,
  /** The MIME type of the task file. */
  val mimeType: String,
  /** The server response of the url request. */
  val rawResponse: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TaskCompleteData {
      val path = pigeonVar_list[0] as String
      val mimeType = pigeonVar_list[1] as String
      val rawResponse = pigeonVar_list[2] as String
      return TaskCompleteData(path, mimeType, rawResponse)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      path,
      mimeType,
      rawResponse,
    )
  }
}

/**
 * The task used by native code for execution.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class Task (
  /** The type of task to execute. */
  val type: TaskType,
  /** The unique identifier of the task. */
  val id: String,
  /** The group identifier of the task. */
  val group: String,
  /** The HTTP method to use for the request. */
  val method: String,
  /** The headers to send with the request. */
  val headers: Map<String, String>,
  /** The timeout for the task in milliseconds. */
  val timeout: Long,
  /** The number of times to retry the task request if it fails. */
  val retries: Long,
  /** The proxy address to use for the task request. */
  val proxyAddress: String? = null,
  /** The proxy port to use with the proxy address. */
  val proxyPort: Long? = null,
  /**
   * The url to use for the task request. This is required for all the tasks
   * that are not of type [TaskType.parallelDownload].
   */
  val url: String? = null,
  /**
   * A list of urls to use for the task request. This is required for tasks of
   * type [TaskType.parallelDownload].
   */
  val urls: List<String>? = null,
  /** The number of chunks to download per URL for [TaskType.parallelDownload]. */
  val chunks: Long? = null,
  /**
   * The directory URI for download tasks.
   *
   * Used in place of [baseDirectory]/[directory].
   */
  val directoryUri: String? = null,
  /** The base directory for the task files. */
  val baseDirectory: StorageDirectory,
  /** The child directory within the base directory for the task files. */
  val directory: String? = null,
  /** The filename of the task file. */
  val filename: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): Task {
      val type = pigeonVar_list[0] as TaskType
      val id = pigeonVar_list[1] as String
      val group = pigeonVar_list[2] as String
      val method = pigeonVar_list[3] as String
      val headers = pigeonVar_list[4] as Map<String, String>
      val timeout = pigeonVar_list[5] as Long
      val retries = pigeonVar_list[6] as Long
      val proxyAddress = pigeonVar_list[7] as String?
      val proxyPort = pigeonVar_list[8] as Long?
      val url = pigeonVar_list[9] as String?
      val urls = pigeonVar_list[10] as List<String>?
      val chunks = pigeonVar_list[11] as Long?
      val directoryUri = pigeonVar_list[12] as String?
      val baseDirectory = pigeonVar_list[13] as StorageDirectory
      val directory = pigeonVar_list[14] as String?
      val filename = pigeonVar_list[15] as String?
      return Task(type, id, group, method, headers, timeout, retries, proxyAddress, proxyPort, url, urls, chunks, directoryUri, baseDirectory, directory, filename)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      type,
      id,
      group,
      method,
      headers,
      timeout,
      retries,
      proxyAddress,
      proxyPort,
      url,
      urls,
      chunks,
      directoryUri,
      baseDirectory,
      directory,
      filename,
    )
  }
}

/**
 * Represents a task event.
 *
 * Generated class from Pigeon that represents data sent in messages.
 * This class should not be extended by any user class outside of the generated file.
 */
sealed class TaskEvent 
/**
 * The status event of a task execution.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TaskStatus (
  /** The task id. */
  val taskId: String,
  /** The task group. */
  val taskGroup: String,
  /** The current state of the task. */
  val state: TaskState,
  /** The data associated with a [TaskState.completed] state. */
  val completeData: TaskCompleteData? = null,
  /** The data associated with a [TaskState.paused] state. */
  val resumeData: TaskResumeData? = null,
  /**
   * The exception that occurred during the task execution. This is only
   * provided if the task state is [TaskState.failed].
   */
  val exception: TaskException? = null
) : TaskEvent()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TaskStatus {
      val taskId = pigeonVar_list[0] as String
      val taskGroup = pigeonVar_list[1] as String
      val state = pigeonVar_list[2] as TaskState
      val completeData = pigeonVar_list[3] as TaskCompleteData?
      val resumeData = pigeonVar_list[4] as TaskResumeData?
      val exception = pigeonVar_list[5] as TaskException?
      return TaskStatus(taskId, taskGroup, state, completeData, resumeData, exception)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      taskId,
      taskGroup,
      state,
      completeData,
      resumeData,
      exception,
    )
  }
}

/**
 * The progress event of a task execution.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TaskProgress (
  /** The task id. */
  val taskId: String,
  /** The task group. */
  val taskGroup: String,
  /** The progress of the task. */
  val progress: Long,
  /** The progress data of the task. */
  val data: TaskProgressData
) : TaskEvent()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TaskProgress {
      val taskId = pigeonVar_list[0] as String
      val taskGroup = pigeonVar_list[1] as String
      val progress = pigeonVar_list[2] as Long
      val data = pigeonVar_list[3] as TaskProgressData
      return TaskProgress(taskId, taskGroup, progress, data)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      taskId,
      taskGroup,
      progress,
      data,
    )
  }
}
private open class FlowPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          StorageDirectory.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          TaskType.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          TaskState.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          TaskErrorCode.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TaskException.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TaskProgressData.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TaskResumeData.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TaskCompleteData.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Task.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TaskStatus.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TaskProgress.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is StorageDirectory -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is TaskType -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is TaskState -> {
        stream.write(131)
        writeValue(stream, value.raw)
      }
      is TaskErrorCode -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is TaskException -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is TaskProgressData -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is TaskResumeData -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is TaskCompleteData -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is Task -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is TaskStatus -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is TaskProgress -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface FileFlowHostApi {
  /**
   * Enqueues a task for execution.
   *
   * Returns `true` if the task was successfully enqueued; otherwise, `false`.
   */
  fun enqueue(task: Task): Boolean
  /**
   * Pauses a task with the specified id.
   *
   * Returns `true` if the task was successfully paused; otherwise, `false`.
   */
  fun pauseWithId(taskId: String): Boolean
  /**
   * Resumes a task with the specified resume data.
   *
   * Returns `true` if the task was successfully resumed; otherwise, `false`.
   */
  fun resume(resumeData: TaskResumeData): Boolean
  /**
   * Cancels a task with the specified id.
   *
   * Returns `true` if the task was successfully canceled; otherwise, `false`.
   */
  fun cancelWithId(taskId: String): Boolean

  companion object {
    /** The codec used by FileFlowHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      FlowPigeonCodec()
    }
    /** Sets up an instance of `FileFlowHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: FileFlowHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.file_flow.FileFlowHostApi.enqueue$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val taskArg = args[0] as Task
            val wrapped: List<Any?> = try {
              listOf(api.enqueue(taskArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.file_flow.FileFlowHostApi.pauseWithId$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val taskIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.pauseWithId(taskIdArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.file_flow.FileFlowHostApi.resume$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val resumeDataArg = args[0] as TaskResumeData
            val wrapped: List<Any?> = try {
              listOf(api.resume(resumeDataArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.file_flow.FileFlowHostApi.cancelWithId$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val taskIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              listOf(api.cancelWithId(taskIdArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class FileFlowFlutterApi(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by FileFlowFlutterApi. */
    val codec: MessageCodec<Any?> by lazy {
      FlowPigeonCodec()
    }
  }
  /** Handles the status update of a task. */
  fun onStatusUpdate(taskStatusArg: TaskStatus, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.file_flow.FileFlowFlutterApi.onStatusUpdate$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(taskStatusArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlowFlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
  /** Handles the progress update of a task. */
  fun onProgressUpdate(taskProgressArg: TaskProgress, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.file_flow.FileFlowFlutterApi.onProgressUpdate$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(taskProgressArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlowFlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      } 
    }
  }
}
